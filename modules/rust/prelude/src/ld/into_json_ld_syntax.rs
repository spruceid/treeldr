use std::borrow::Cow;

use contextual::WithContext;
use rdf_types::{Literal, Namespace, Object, Quad, Subject};

use crate::Id;

pub trait IntoJsonLdSyntax<N, M = ()> {
	fn into_json_ld_syntax(self, namespace: &N) -> json_ld::syntax::Value<M>;
}

macro_rules! impl_into_json_ld_syntax_literal {
	{ $($ty:ty : $rdf_ty:tt),* } => {
		$(
			impl<N, M> IntoJsonLdSyntax<N, M> for $ty {
				fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
					json_ld::syntax::Value::String(self.to_string().into())
				}
			}
		)*
	};
}

impl_into_json_ld_syntax_literal! {
	xsd_types::Boolean: "http://www.w3.org/2001/XMLSchema#boolean",
	xsd_types::Decimal: "http://www.w3.org/2001/XMLSchema#decimal",
	xsd_types::Integer: "http://www.w3.org/2001/XMLSchema#integer",
	xsd_types::Long: "http://www.w3.org/2001/XMLSchema#long",
	xsd_types::Int: "http://www.w3.org/2001/XMLSchema#int",
	xsd_types::Short: "http://www.w3.org/2001/XMLSchema#short",
	xsd_types::Byte: "http://www.w3.org/2001/XMLSchema#byte",
	xsd_types::NonNegativeInteger: "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
	xsd_types::PositiveInteger: "http://www.w3.org/2001/XMLSchema#positiveInteger",
	xsd_types::UnsignedLong: "http://www.w3.org/2001/XMLSchema#unsignedLong",
	xsd_types::UnsignedInt: "http://www.w3.org/2001/XMLSchema#unsignedInt",
	xsd_types::UnsignedShort: "http://www.w3.org/2001/XMLSchema#unsignedShort",
	xsd_types::UnsignedByte: "http://www.w3.org/2001/XMLSchema#unsignedByte",
	xsd_types::NonPositiveInteger: "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
	xsd_types::NegativeInteger: "http://www.w3.org/2001/XMLSchema#negativeInteger",
	xsd_types::Double: "http://www.w3.org/2001/XMLSchema#double",
	xsd_types::Float: "http://www.w3.org/2001/XMLSchema#float",
	xsd_types::String: "http://www.w3.org/2001/XMLSchema#string",
	xsd_types::Base64BinaryBuf: "http://www.w3.org/2001/XMLSchema#base64Binary",
	xsd_types::HexBinaryBuf: "http://www.w3.org/2001/XMLSchema#hexBinary"
}

impl<N, M> IntoJsonLdSyntax<N, M> for chrono::NaiveDate {
	fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
		json_ld::syntax::Value::String(self.to_string().into())
	}
}

impl<N, M> IntoJsonLdSyntax<N, M> for chrono::DateTime<chrono::Utc> {
	fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
		json_ld::syntax::Value::String(self.to_string().into())
	}
}

impl<N, M> IntoJsonLdSyntax<N, M> for iref::IriBuf {
	fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
		json_ld::syntax::Value::String(self.to_string().into())
	}
}

impl<N, M> IntoJsonLdSyntax<N, M> for iref::IriRefBuf {
	fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
		json_ld::syntax::Value::String(self.to_string().into())
	}
}

impl<N, I: std::fmt::Display, B: std::fmt::Display, M> IntoJsonLdSyntax<N, M> for Subject<I, B> {
	fn into_json_ld_syntax(self, _namespace: &N) -> json_ld::syntax::Value<M> {
		match self {
			Subject::Iri(i) => json_ld::syntax::Value::String(i.to_string().into()),
			Subject::Blank(b) => json_ld::syntax::Value::String(b.to_string().into()),
		}
	}
}

impl<N: Namespace, M> IntoJsonLdSyntax<N, M> for Id<N::Id>
where
	N::Id: contextual::DisplayWithContext<N>,
{
	fn into_json_ld_syntax(self, namespace: &N) -> json_ld::syntax::Value<M> {
		json_ld::syntax::Value::String(self.0.with(namespace).to_string().into())
	}
}

/// RDF Quad imported from the `json_ld` library by using the [`import_quad`]
/// function to clone the components of a `GeneratedQuad`.
pub type ImportedQuad<'a, I, B> = Quad<
	rdf_types::Id<I, B>,
	rdf_types::Id<I, B>,
	Object<rdf_types::Id<I, B>, Literal<String, I>>,
	&'a rdf_types::Id<I, B>,
>;

/// RDF Quad generated by the `json_ld` library.
pub type GeneratedQuad<'a, I, B> = rdf_types::Quad<
	Cow<'a, rdf_types::Id<I, B>>,
	Cow<'a, rdf_types::Id<I, B>>,
	Object<rdf_types::Id<I, B>, Literal<String, I>>,
	&'a rdf_types::Id<I, B>,
>;

/// Converts a `GeneratedQuad` into an `ImportedQuad` by copying the borrowed
/// subject and predicate.
pub fn import_quad<I: Clone, B: Clone>(
	Quad(subject, predicate, object, graph): GeneratedQuad<I, B>,
) -> ImportedQuad<I, B> {
	let subject = subject.as_ref().clone();
	let predicate = predicate.as_ref().clone();
	Quad(subject, predicate, object, graph)
}
